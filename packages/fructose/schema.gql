schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

directive @graphinx(module: String) on OBJECT | FIELD_DEFINITION | SCALAR | ENUM | UNION | INTERFACE | INPUT_OBJECT

"""
Represents a user account with associated mailboxes and server configurations.
"""
type Account implements Node {
  """The email address of the account."""
  address: EmailAddress!
  """The drafts mailbox for the account."""
  draftsbox: Mailbox
  """First maibox of type FEED"""
  feedbox: Mailbox
  id: ID!
  """Get a mailbox on this account by its ID"""
  inbox(id: ID!): Mailbox
  """List of mailboxes associated with the account."""
  inboxes(
    """Include empty inboxes"""
    empty: Boolean = false
    """Return only inboxes of the given types"""
    type: [MailboxType!]
  ): [Mailbox!]!
  """The primary inbox for the account."""
  mainbox: Mailbox
  """The display name of the account holder."""
  name: String!
  """Server used for receiving emails."""
  receiverServer: Server!
  """Server used for sending emails."""
  senderServer: Server
  """The sent mailbox for the account."""
  sentbox: Mailbox
  """The trash mailbox for the account."""
  trashbox: Mailbox
}

input AccountInput {
  host: String
  name: String
  password: String
  port: Int! = 993
  tls: Boolean! = true
  username: String
}

"""Represents an email address with optional metadata."""
type Address implements Node {
  """The email address."""
  address: String!
  """A avatar URL for this address"""
  avatarURL: URL
  """Emails where this address is in the CC field."""
  ccEmails(after: String, before: String, first: Int, last: Int): EmailConnection!
  id: ID!
  """Indicates whether the address is known (for recipients)."""
  known: Boolean
  """The name associated with the email address."""
  name: String!
  probablyAPerson: Boolean!
  """Emails received by this address."""
  receivedEmails(after: String, before: String, first: Int, last: Int): EmailConnection!
  """Emails sent by this address."""
  sentEmails(after: String, before: String, first: Int, last: Int): EmailConnection!
  """Indicates whether the address is verified (for senders)."""
  verified: Boolean
}

enum AddressType {
  RECIPIENT
  SENDER
}

type Attachment implements Node {
  """The MIME type of the attachment."""
  contentType: String!
  """The email that contains this attachment."""
  email: Email!
  """The attachment is an embedded file."""
  embedded: Boolean!
  """The filename of the attachment."""
  filename: String!
  id: ID!
  """The size of the attachment in bytes."""
  size: Int!
  """Extracted text content of the attachment."""
  textContent: String!
  url: URL!
}

"""
A field whose value is a hex color code: https://en.wikipedia.org/wiki/Web_colors.
"""
scalar Color

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

"""Represents an email message."""
type Email implements Node {
  """Attachments included in the email."""
  attachments(
    after: String
    before: String
    """Include embedded attachments"""
    embedded: Boolean = false
    first: Int
    last: Int
  ): EmailAttachmentsConnection!
  attachmentsBaseURL: String!
  """List of carbon copy (CC) recipients."""
  cc: [Address!]!
  """Result of the DKIM check"""
  dkim: EmailAuthenticationResult
  """Result of the DMARC check"""
  dmarc: EmailAuthenticationResult
  """The sender of the email."""
  from: Address!
  """
  Check if the email has a header by its key. Example: `{ email(...) { respectsPeople: hasHeader(key: "List-Unsubscribe") } } `
  """
  hasHeader(key: String!): Boolean!
  """Get all the values of a header by its key"""
  header(key: String!): [String!]!
  """Headers of the email"""
  headers: [Header!]!
  """The HTML body content of the email."""
  html: HTML!
  id: ID!
  """The mailbox that contains the email."""
  inbox: Mailbox!
  """The raw, entire body of the email (all parts)."""
  raw: String!
  """Date and time the email was received."""
  receivedAt: DateTime!
  """The subject was changed by the user"""
  renamed: Boolean!
  """Emaisl that reference this email as part of their thread."""
  replies(after: String, before: String, first: Int, last: Int): EmailConnection!
  """Result of the SPF check"""
  spf: EmailAuthenticationResult
  """The subject of the email"""
  subject(
    """
    Return the original subject even if the mail was renamed (see Mail.renamed)
    """
    original: Boolean = false
  ): String!
  """The text body content of the email."""
  text: String!
  """The primary recipient of the email."""
  to: Address!
  """Indicates whether the email is trusted (not spam)."""
  trusted: Boolean!
  """URL to unsubscribe from the email"""
  unsubscribe: URL
}

"""
A field whose value conforms to the standard internet email address format as specified in HTML Spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address.
"""
scalar EmailAddress

type EmailAttachmentsConnection {
  edges: [EmailAttachmentsConnectionEdge!]!
  nodes: [Attachment!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type EmailAttachmentsConnectionEdge {
  cursor: String!
  node: Attachment!
}

type EmailAuthenticationResult {
  """Reason for the authentication check (why it passed or failed)"""
  explanation: String!
  """The authentication check passed"""
  ok: Boolean!
}

type EmailConnection {
  edges: [EmailEdge!]!
  nodes: [Email!]!
  pageInfo: PageInfo!
}

type EmailEdge {
  cursor: String!
  node: Email!
}

"""
The most basic error object, based on the base JavaScript Error object.
"""
type Error implements ErrorInterface {
  message: String!
}

"""Basic interface for all error types to implement."""
interface ErrorInterface {
  message: String!
}

scalar HTML

type Header {
  email: Email!
  key: String!
  value: String!
}

"""Represents a label applied to an email."""
type Label implements Node {
  """Color code for the label."""
  color: Color!
  """Emails with this label."""
  emails(after: String, before: String, first: Int, last: Int): EmailConnection!
  id: ID!
  """Key for the label (not displayed)."""
  key: String!
  """Display text for the label."""
  text: String!
}

"""Represents a mailbox, such as an inbox, trash, or sent folder."""
type Mailbox implements Node {
  """The account this mailbox belongs to."""
  account: Account!
  """Senders that get sent here by default"""
  defaultOf(after: String, before: String, first: Int, last: Int): MailboxDefaultOfConnection!
  """List of emails stored in this mailbox."""
  emails(
    after: String
    before: String
    first: Int
    """Include emails from unscreened senders"""
    includeUnscreened: Boolean = false
    last: Int
  ): EmailConnection!
  id: ID!
  """Indicates whether this is the main mailbox."""
  main: Boolean
  """
  The mailbox's name. The special inbox name 'INBOX' is replaced with 'Main'
  """
  name: String
  """The type of mailbox (e.g., Inbox, Trashbox, Sentbox)."""
  type: MailboxType!
  """Account that uses this mailbox as the drafts mailbox."""
  usedAsDraftsboxOn: [Account!]!
  """Account that uses this mailbox as the main mailbox."""
  usedAsMainboxOn: [Account!]!
  """Account that uses this mailbox as the sent mailbox."""
  usedAsSentboxOn: [Account!]!
  """Account that uses this mailbox as the trash mailbox."""
  usedAsTrashboxOn: [Account!]!
}

type MailboxConnection {
  edges: [MailboxEdge!]!
  nodes: [MailboxType!]!
  pageInfo: PageInfo!
}

type MailboxDefaultOfConnection {
  edges: [MailboxDefaultOfConnectionEdge!]!
  nodes: [Address!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type MailboxDefaultOfConnectionEdge {
  cursor: String!
  node: Address!
}

type MailboxEdge {
  cursor: String!
  node: MailboxType!
}

enum MailboxType {
  DRAFTS
  FEED
  INBOX
  SCREENER
  SENTBOX
  TRASHBOX
}

type Mutation {
  """Change an email's subject"""
  renameEmail(email: ID!, subject: String!): MutationRenameEmailResult!
  """
  Screen an address to a specific inbox. Can also be used on a already screened address to change its default inbox
  """
  screenTo(
    address: EmailAddress!
    """Mailbox to screen the mail to"""
    box: ID!
  ): MutationScreenToResult!
  """Send an email"""
  sendEmail(
    body: String!
    """
    Email address must have a connected account with a sender server configured
    """
    from: EmailAddress!
    """Reply to another email"""
    inReply: ID
    subject: String!
    to: EmailAddress!
  ): MutationSendEmailResult!
  upsertAccount(address: EmailAddress!, input: AccountInput!): MutationUpsertAccountResult!
}

union MutationRenameEmailResult = Error | MutationRenameEmailSuccess | ZodError

type MutationRenameEmailSuccess {
  data: Email!
}

union MutationScreenToResult = Error | MutationScreenToSuccess | ZodError

type MutationScreenToSuccess {
  data: Address!
}

union MutationSendEmailResult = Error | MutationSendEmailSuccess | ZodError

type MutationSendEmailSuccess {
  data: Boolean!
}

union MutationUpsertAccountResult = Error | MutationUpsertAccountSuccess | ZodError

type MutationUpsertAccountSuccess {
  data: Account!
}

interface Node {
  id: ID!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Query {
  account(address: EmailAddress!): Account
  accounts: [Account!]!
  """Find an address by its email address"""
  address(email: EmailAddress!): Address
  """Get all addresses"""
  addresses(after: String, before: String, first: Int, last: Int): QueryAddressesConnection!
  """Find a mail by id"""
  email(id: ID!): Email
  emails(after: String, before: String, first: Int, inbox: ID!, last: Int): QueryEmailsConnection!
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]!
  """
  Addresses that are waiting screening (have not been assigned a default inbox yet).
  """
  screenings(after: String, before: String, first: Int, last: Int): QueryScreeningsConnection!
}

type QueryAddressesConnection {
  edges: [QueryAddressesConnectionEdge!]!
  nodes: [Address!]!
  pageInfo: PageInfo!
}

type QueryAddressesConnectionEdge {
  cursor: String!
  node: Address!
}

type QueryEmailsConnection {
  edges: [QueryEmailsConnectionEdge!]!
  nodes: [Email!]!
  pageInfo: PageInfo!
}

type QueryEmailsConnectionEdge {
  cursor: String!
  node: Email!
}

type QueryScreeningsConnection {
  edges: [QueryScreeningsConnectionEdge!]!
  nodes: [Address!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type QueryScreeningsConnectionEdge {
  cursor: String!
  node: Address!
}

"""Represents an email server used for sending or receiving emails."""
type Server implements Node {
  """Hostname of the server."""
  host: String!
  id: ID!
  """Password for authentication (optional for OAuth2)."""
  password: String
  """Port number for the server."""
  port: Int!
  """Accounts that use this server for receiving emails."""
  receiverAccounts: [Account!]!
  """Indicates whether the connection to the server is secure."""
  secure: Boolean!
  """Accounts that use this server for sending emails."""
  senderAccounts: [Account!]!
  """OAuth2 token for authentication (optional for password-based auth)."""
  token: String
  """The type of server (SMTP, IMAP, etc.)."""
  type: ServerType!
  """The username used to authenticate with the server."""
  username: String!
}

enum ServerType {
  Google
  IMAP
  SMTP
}

type Subscription {
  emails(after: String, before: String, first: Int, inbox: ID!, last: Int): QueryEmailsConnection!
  """Check if the daemon listening for new mail is running."""
  idlerIsOnline: Boolean!
  """
  Addresses that are waiting screening (have not been assigned a default inbox yet).
  """
  screenings(after: String, before: String, first: Int, last: Int): QueryScreeningsConnection!
}

"""
Une adresse internet (URL). Les protocoles autorisés sont: http:, https:, mailto:, tel:
"""
scalar URL

"""A validation error, as a list of field errors."""
type ZodError implements ErrorInterface {
  fieldErrors: [ZodFieldError!]!
  message: String!
}

"""A validation issue for a field."""
type ZodFieldError {
  message: String!
  path: [String!]!
}